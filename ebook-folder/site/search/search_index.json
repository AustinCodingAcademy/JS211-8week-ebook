{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to JS211 - Foundations in Programming Objective Statement Through this course students will learn to program by building simple and basic applications. The focus of this course is programmatic logic with a secondary focus on syntax. This course uses JavaScript as a language/syntax and Node.js as an environment to run JavaScript outside of a web browser. The skills learned in this course directly translate to other programming languages. While client-facing G raphical U ser I nterfaces (GUIs) are recommended as extended practice, there is no need for a student to worry if they are unable to build a GUI for every one of their terminal-based applications(CLI). In this course, students get a real chance to develop their own problem-solving strategies. There is no one right way to do any of them. In addition, the skills learned in this course directly translate to the skills learned in the 311 and 411 courses in a more practical and realistic sense. Instead of learning various methods, programming patterns, and data manipulation in isolation, students will spread their understanding and familiarity with programming over the development of their graduation app in the following 311 and 411 courses. Our philosophy is \"learn by doing\". We engage our students in the problem solving process as opposed to relying heavily on lectures. Our instructors, who are real developers, facilitate learning through guiding your progress as you work through projects on your own. To be successful in this course, you must spend 10-15 hours outside of class completing Pre-Class Lessons before each Class Lesson. Our class structure follows the flipped classroom model where students learn on their own outside of class and bring their questions with them to class. Class begins by discussing the \"Questions for Discussion & Terms to Know\", and the majority of class time is spent working on projects. READ ON, start with Pre-Course Pt 1: How to Succeed and work through all 5 sections BEFORE you come to class on the first day! Class Structure and Expectations This class will follow a Flipped-Classroom methodology. This means you, the student, are required to complete the assigned Pre-Homework before each day of class. You will not succeed in this course if you don't complete the Pre-Homework. Working on the Pre-Homework during class takes away from other students, ruins your chance to deeply understand the material, and ask import questions! Don't be the guy! Due dates : Homework is due the Sunday after it is assigned. (unless otherwise specified). Please have your assignment turned in by the end of Sunday night. Due dates are scheduled on Sunday for you to attend Study Sessions on the weekend. GET IT DONE! Both Daily and Checkpoint Assignments are due the Sunday after they are assigned, the Submission Due Day , i.e. Ticket-Counter is assigned Wednesday and will be due for submission 4 days later on Sunday. Assignments turned in after the Submission Due Day will be penalized with -20 points, in other words, only a maximum grade of 80 is possible. The third Checkpoint for each course, (101 - 411) will be due the Sunday following the last day of the course. Work turned in after this will be subject to -20 penalty. The Final Submission Day for any late assignments is the Second Sunday after each course ends. Assignments turned in after the Final Submission Day will receive an automatic grade of 50. Homework submission : Turn in your homework on Campus Manager. Copy/paste a link to your completed assignment(GitHub Pull Request or repo URL) in the designated spot for the assignment. For assignments that cannot be accessed via link, we'll make other arrangements on a case-by-case basis. Homework guidelines : Your work should be thorough and demonstrate an understanding of the topic and tasks set forth. Please make sure that your assignments are detailed with comments, inclusive of all specifications, and complete. Grading : You Instructor will be grading your assignments based on their functionality and completion of the specifications laid out for each assignment. Late policy : You may receive up to a 70 for an assignment that is turned in late. It is up to you, the student, to request the instructor grade the assignment after you have submitted it. Additionally, if you have 3 late or missing assignments in a row, you'll be asked to read a programming-related article of your choice and make a 3-minute presentation about it to the class. Exceptions : If you need to turn in an assignment late or will be tardy/absent to a class please email your Instructor and Campus Director ahead of time to make appropriate arrangements. To Pass This Class (and all others) Finish with a grade average of >70, Attend class 80% of the time, Complete your Final Checkpoint, Present to the class specs for the app you are planning to build for your Capstone Project. How To Use This Textbook Video","title":"Home"},{"location":"#welcome-to-js211-foundations-in-programming","text":"","title":"Welcome to JS211 - Foundations in Programming"},{"location":"#objective-statement","text":"Through this course students will learn to program by building simple and basic applications. The focus of this course is programmatic logic with a secondary focus on syntax. This course uses JavaScript as a language/syntax and Node.js as an environment to run JavaScript outside of a web browser. The skills learned in this course directly translate to other programming languages. While client-facing G raphical U ser I nterfaces (GUIs) are recommended as extended practice, there is no need for a student to worry if they are unable to build a GUI for every one of their terminal-based applications(CLI). In this course, students get a real chance to develop their own problem-solving strategies. There is no one right way to do any of them. In addition, the skills learned in this course directly translate to the skills learned in the 311 and 411 courses in a more practical and realistic sense. Instead of learning various methods, programming patterns, and data manipulation in isolation, students will spread their understanding and familiarity with programming over the development of their graduation app in the following 311 and 411 courses. Our philosophy is \"learn by doing\". We engage our students in the problem solving process as opposed to relying heavily on lectures. Our instructors, who are real developers, facilitate learning through guiding your progress as you work through projects on your own. To be successful in this course, you must spend 10-15 hours outside of class completing Pre-Class Lessons before each Class Lesson. Our class structure follows the flipped classroom model where students learn on their own outside of class and bring their questions with them to class. Class begins by discussing the \"Questions for Discussion & Terms to Know\", and the majority of class time is spent working on projects. READ ON, start with Pre-Course Pt 1: How to Succeed and work through all 5 sections BEFORE you come to class on the first day!","title":"Objective Statement"},{"location":"#class-structure-and-expectations","text":"This class will follow a Flipped-Classroom methodology. This means you, the student, are required to complete the assigned Pre-Homework before each day of class. You will not succeed in this course if you don't complete the Pre-Homework. Working on the Pre-Homework during class takes away from other students, ruins your chance to deeply understand the material, and ask import questions! Don't be the guy! Due dates : Homework is due the Sunday after it is assigned. (unless otherwise specified). Please have your assignment turned in by the end of Sunday night. Due dates are scheduled on Sunday for you to attend Study Sessions on the weekend. GET IT DONE! Both Daily and Checkpoint Assignments are due the Sunday after they are assigned, the Submission Due Day , i.e. Ticket-Counter is assigned Wednesday and will be due for submission 4 days later on Sunday. Assignments turned in after the Submission Due Day will be penalized with -20 points, in other words, only a maximum grade of 80 is possible. The third Checkpoint for each course, (101 - 411) will be due the Sunday following the last day of the course. Work turned in after this will be subject to -20 penalty. The Final Submission Day for any late assignments is the Second Sunday after each course ends. Assignments turned in after the Final Submission Day will receive an automatic grade of 50. Homework submission : Turn in your homework on Campus Manager. Copy/paste a link to your completed assignment(GitHub Pull Request or repo URL) in the designated spot for the assignment. For assignments that cannot be accessed via link, we'll make other arrangements on a case-by-case basis. Homework guidelines : Your work should be thorough and demonstrate an understanding of the topic and tasks set forth. Please make sure that your assignments are detailed with comments, inclusive of all specifications, and complete. Grading : You Instructor will be grading your assignments based on their functionality and completion of the specifications laid out for each assignment. Late policy : You may receive up to a 70 for an assignment that is turned in late. It is up to you, the student, to request the instructor grade the assignment after you have submitted it. Additionally, if you have 3 late or missing assignments in a row, you'll be asked to read a programming-related article of your choice and make a 3-minute presentation about it to the class. Exceptions : If you need to turn in an assignment late or will be tardy/absent to a class please email your Instructor and Campus Director ahead of time to make appropriate arrangements.","title":"Class Structure and Expectations"},{"location":"#to-pass-this-class-and-all-others","text":"Finish with a grade average of >70, Attend class 80% of the time, Complete your Final Checkpoint, Present to the class specs for the app you are planning to build for your Capstone Project.","title":"To Pass This Class (and all others)"},{"location":"#how-to-use-this-textbook-video","text":"","title":"How To Use This Textbook Video"},{"location":"additionalResources/gitCommands/","text":"Git Commands Useful Git Commands git init - initialize a local folder as a git repo to be tracked and push to the cloud git branch branch_name - Create the branch on your local machine called \"branch_name\". git checkout -b branch_name - Create the branch on your local machine and switch into this branch. git checkout branch_name - Switch into this branch. git status - Check the status of tracked/untracked changed files git add fileName.js - Add the file \"fileName.js\" to be tracked for the next commit. git add . - Add all changed files to be tracked. git commit -m \"message\" - Make a commit with the message \"message\". git push - Push the commit to the current working branch git push origin branch_name - Push the commit to the branch \"branch_name\" git pull - Pulls down changes from the repo to bring your local codebase up-to-date","title":"Git Commands"},{"location":"additionalResources/gitCommands/#git-commands","text":"","title":"Git Commands"},{"location":"additionalResources/gitCommands/#useful-git-commands","text":"git init - initialize a local folder as a git repo to be tracked and push to the cloud git branch branch_name - Create the branch on your local machine called \"branch_name\". git checkout -b branch_name - Create the branch on your local machine and switch into this branch. git checkout branch_name - Switch into this branch. git status - Check the status of tracked/untracked changed files git add fileName.js - Add the file \"fileName.js\" to be tracked for the next commit. git add . - Add all changed files to be tracked. git commit -m \"message\" - Make a commit with the message \"message\". git push - Push the commit to the current working branch git push origin branch_name - Push the commit to the branch \"branch_name\" git pull - Pulls down changes from the repo to bring your local codebase up-to-date","title":"Useful Git Commands"},{"location":"additionalResources/graduationPrerequisites/","text":"Graduation Prerequisites A graduate of this program will receive a digital certificate from ACA by: Completing all 4 courses with an overall grade average of >70, Each course must also be completed with a grade average of >70, Build a full-stack web application using the technology learned in these past 4 courses that: Has a SQL Database, Has an rest API to serve the data, Uses an third-party API, Has a sign-in strategy, Has a client-side app for a user to interact with, Deploy and Host the Capstone Project. Is deployed and publicly accessible, Is linked to the ACA website.","title":"Graduation Prerequisites"},{"location":"additionalResources/graduationPrerequisites/#graduation-prerequisites","text":"A graduate of this program will receive a digital certificate from ACA by: Completing all 4 courses with an overall grade average of >70, Each course must also be completed with a grade average of >70, Build a full-stack web application using the technology learned in these past 4 courses that: Has a SQL Database, Has an rest API to serve the data, Uses an third-party API, Has a sign-in strategy, Has a client-side app for a user to interact with, Deploy and Host the Capstone Project. Is deployed and publicly accessible, Is linked to the ACA website.","title":"Graduation Prerequisites"},{"location":"additionalResources/keyboardShortcuts/","text":"Keyboard Shortcuts Short-cuts macOS Keyboard Shortcuts Windows Keyboard Shortcuts VS Code Shortcuts","title":"Keyboard Shortcuts"},{"location":"additionalResources/keyboardShortcuts/#keyboard-shortcuts","text":"","title":"Keyboard Shortcuts"},{"location":"additionalResources/keyboardShortcuts/#short-cuts","text":"macOS Keyboard Shortcuts Windows Keyboard Shortcuts VS Code Shortcuts","title":"Short-cuts"},{"location":"additionalResources/presentationsQualifications/","text":"Presentations Qualifications To be eligible to present your Capstone Project to the public, family, friends, and recruiters at the graduation ceremony held after the conclusion of this course the candidate must: Complete the requirements to graduate (see above) Deploy and host your Capstone Project Rehearse the 5-minute presentation with your Job Placement Instructor and Campus Director. Capstone Project Presentation Guidelines The purpose of the presentation is to: Celebrate the graduates new skills, mindset, and confidence. Share with the community the student's ideas and new skills. Practice speaking in-public about technology. A well prepared 3-minute presentation will include: Graduates Name and skills they've been studying The problem the graduate was trying to solve with this app. How the app solves the problem with a demonstration of the app. Where the graduate would like to take the app in the future. Invitation to share the code base with interested patrons after graduation. The presentation should NOT include: An emphasis on sign-on. ( all web apps have a sign-on ) Showing of any code. ( your attendees don't care about code )","title":"Presentations Qualifications"},{"location":"additionalResources/presentationsQualifications/#presentations-qualifications","text":"To be eligible to present your Capstone Project to the public, family, friends, and recruiters at the graduation ceremony held after the conclusion of this course the candidate must: Complete the requirements to graduate (see above) Deploy and host your Capstone Project Rehearse the 5-minute presentation with your Job Placement Instructor and Campus Director.","title":"Presentations Qualifications"},{"location":"additionalResources/presentationsQualifications/#capstone-project-presentation-guidelines","text":"The purpose of the presentation is to: Celebrate the graduates new skills, mindset, and confidence. Share with the community the student's ideas and new skills. Practice speaking in-public about technology. A well prepared 3-minute presentation will include: Graduates Name and skills they've been studying The problem the graduate was trying to solve with this app. How the app solves the problem with a demonstration of the app. Where the graduate would like to take the app in the future. Invitation to share the code base with interested patrons after graduation. The presentation should NOT include: An emphasis on sign-on. ( all web apps have a sign-on ) Showing of any code. ( your attendees don't care about code )","title":"Capstone Project Presentation Guidelines"},{"location":"additionalResources/studentPresentations/","text":"Daily Student Presentations Class 5 - Organize and Coordinate who and when students are presenting. Class 6 - Pitch your graduation app to the class. What\u2019s the problem? How does this app solve it? Class 7 - Pitch your graduation app to the class. What\u2019s the problem? How does this app solve it? Class 8 - Pitch your graduation app to the class. What\u2019s the problem? How does this app solve it? Class 9 - todo todo Class 10 - todo todo Class 11 - todo todo Class 12 - todo todo Class 13 - todo todo Class 14 - todo todo Class 15 - todo todo Class 16 - todo todo Class 17 - todo todo Class 18 - todo todo Class 19 - todo todo Class 20 - todo todo","title":"Student Presentations"},{"location":"additionalResources/studentPresentations/#daily-student-presentations","text":"Class 5 - Organize and Coordinate who and when students are presenting. Class 6 - Pitch your graduation app to the class. What\u2019s the problem? How does this app solve it? Class 7 - Pitch your graduation app to the class. What\u2019s the problem? How does this app solve it? Class 8 - Pitch your graduation app to the class. What\u2019s the problem? How does this app solve it? Class 9 - todo todo Class 10 - todo todo Class 11 - todo todo Class 12 - todo todo Class 13 - todo todo Class 14 - todo todo Class 15 - todo todo Class 16 - todo todo Class 17 - todo todo Class 18 - todo todo Class 19 - todo todo Class 20 - todo todo","title":"Daily Student Presentations"},{"location":"additionalResources/whiteboardingChallenges/","text":"Whiteboarding Challenges Class 5: Prompt 1: todo Prompt 2: todo Class 6: Prompt 1: todo Prompt 2: todo Class 7: Prompt 1: todo Prompt 2: todo Class 8: Prompt 1: todo Prompt 2: todo Class 9: Prompt 1: todo Prompt 2: todo Class 10: Prompt 1: todo Prompt 2: todo Class 11: Prompt 1: todo Prompt 2: todo Class 12: Prompt 1: todo Prompt 2: todo Class 13: Prompt 1: todo Prompt 2: todo Class 14: Prompt 1: todo Prompt 2: todo Class 15: Prompt 1: todo Prompt 2: todo Class 16: Prompt 1: todo Prompt 2: todo Class 17: Prompt 1: todo Prompt 2: todo Class 18: Prompt 1: todo Prompt 2: todo Class 19: Prompt 1: todo Prompt 2: todo Class 20: Prompt 1: todo Prompt 2: todo","title":"Whiteboarding Challenges"},{"location":"additionalResources/whiteboardingChallenges/#whiteboarding-challenges","text":"Class 5: Prompt 1: todo Prompt 2: todo Class 6: Prompt 1: todo Prompt 2: todo Class 7: Prompt 1: todo Prompt 2: todo Class 8: Prompt 1: todo Prompt 2: todo Class 9: Prompt 1: todo Prompt 2: todo Class 10: Prompt 1: todo Prompt 2: todo Class 11: Prompt 1: todo Prompt 2: todo Class 12: Prompt 1: todo Prompt 2: todo Class 13: Prompt 1: todo Prompt 2: todo Class 14: Prompt 1: todo Prompt 2: todo Class 15: Prompt 1: todo Prompt 2: todo Class 16: Prompt 1: todo Prompt 2: todo Class 17: Prompt 1: todo Prompt 2: todo Class 18: Prompt 1: todo Prompt 2: todo Class 19: Prompt 1: todo Prompt 2: todo Class 20: Prompt 1: todo Prompt 2: todo","title":"Whiteboarding Challenges"},{"location":"module-1/class-plans/classOutlineTemplate/","text":"Class #: Title Instructor Only Content - HIDE FROM STUDENTS Greet, Outline, and Objectify Today we're going to: GENERIC OBJECTIVE: By re-engaging with previously learned knowledge and applying it to a new challenge the student will deepen their understanding and be prepared to creatively reuse these techniques in new ways. GENERIC OBJECTIVE: After learning new content through individual presentations and exploring their uses with familiar tasks the student will gain confidence in their abilities to effectively solve new problems in the future. Questions for Student Led Discussion Interview Challenge Student Presentations Creation Time Push Yourself Further Exit Recap, Attendance, and Reminders Questions for Student Led Discussion, 10-15 minutes First Question: Tell me what you learned. ..? Interview Challenge, 10-15 minutes Prompt: Student Presentations, 10-15 minutes Prompt 1: Prompt 2: Creation Time, 60-90 minutes Push Yourself Further Exit Recap, Attendance, and Reminders, 5 mins","title":"Class 1, Template"},{"location":"module-1/class-plans/classOutlineTemplate/#class-title","text":"","title":"Class #: Title"},{"location":"module-1/class-plans/classOutlineTemplate/#instructor-only-content-hide-from-students","text":"","title":"Instructor Only Content - HIDE FROM STUDENTS"},{"location":"module-1/class-plans/classOutlineTemplate/#greet-outline-and-objectify","text":"Today we're going to: GENERIC OBJECTIVE: By re-engaging with previously learned knowledge and applying it to a new challenge the student will deepen their understanding and be prepared to creatively reuse these techniques in new ways. GENERIC OBJECTIVE: After learning new content through individual presentations and exploring their uses with familiar tasks the student will gain confidence in their abilities to effectively solve new problems in the future. Questions for Student Led Discussion Interview Challenge Student Presentations Creation Time Push Yourself Further Exit Recap, Attendance, and Reminders","title":"Greet, Outline, and Objectify"},{"location":"module-1/class-plans/classOutlineTemplate/#questions-for-student-led-discussion-10-15-minutes","text":"First Question: Tell me what you learned. ..?","title":"Questions for Student Led Discussion, 10-15 minutes"},{"location":"module-1/class-plans/classOutlineTemplate/#interview-challenge-10-15-minutes","text":"Prompt:","title":"Interview Challenge, 10-15 minutes"},{"location":"module-1/class-plans/classOutlineTemplate/#student-presentations-10-15-minutes","text":"Prompt 1: Prompt 2:","title":"Student Presentations, 10-15 minutes"},{"location":"module-1/class-plans/classOutlineTemplate/#creation-time-60-90-minutes","text":"","title":"Creation Time, 60-90 minutes"},{"location":"module-1/class-plans/classOutlineTemplate/#push-yourself-further","text":"","title":"Push Yourself Further"},{"location":"module-1/class-plans/classOutlineTemplate/#exit-recap-attendance-and-reminders-5-mins","text":"","title":"Exit Recap, Attendance, and Reminders, 5 mins"},{"location":"module-1/pre-class-lessons/lessonOutlineTemplate/","text":"Pre-Class Lesson 1: TITLE \u201cIt is always the simple that produces the marvelous.\u201d \u2014Amelia Barr Special Elements like Images Mkdocs and Material along with a nice extension called pym... allow for some serious control over your documentation (learning materials). Here's an example of an image aligned to the right: see it there? We can add any bit of text we want to make our ebook's flow more interestingly! Unfortunately you have to have quite a bit to say here otherwise the next sections gets caught up in here unless you can find a good solution for this!! Using HTML we can create captions And control their dimensions And Videos Link to a video Or embed it on the screen Code Blocks & Snippets Need some code fencing and annotation? Javascript 1 2 3 4 5 const myVariable = 8 const addSix = num => { return num + 6 } Python 1 2 3 4 5 6 my_variable = 8 def add_six ( num ): return num + 6 print ( add_six ( my_variable )) const addSix = num => { When we pass one and only one argument to a function declared with the const keyword we don't HAVE to wrap it with ( ) . 1 2 3 4 5 < section class = \"row gallery-two\" > <!-- Copy/Paste the line below for as many images as you'd like --> < img src = \"\" alt = \"what the image is\" height = \"360\" width = \"240\" > < img src = \"https://media.giphy.com/media/CBnvmgOvK1d9C/giphy.gif\" alt = \"what the image is\" height = \"360\" width = \"240\" > </ section > line numbers :do you like 'em? NOTE: Make sure to indent your fence block's properly. In-line Code + Keyboard buttons!! What about some in-line code ? Like this and .bind() . Or color: , height: , width: , z-index: , font-size: ? What about keys? Ctrl + Alt + Del , Enter , Space , L , or Esc NOTE: Indent additional comments like this. Lots of Lists You can make some really nice lists too!! Here Here Here Or share some tips way computers work way computers work way computers work bullets bullets Or share some tips way computers work way computers work way computers work bullets bullets And check out these checklists! Task One Task One.a Task Two Task Two.a Task Two.b Task Two.c Need a table? Method Description GET Fetch resource PUT Update resource DELETE Delete resource","title":"Intro to Material-Mkdocs"},{"location":"module-1/pre-class-lessons/lessonOutlineTemplate/#pre-class-lesson-1-title","text":"\u201cIt is always the simple that produces the marvelous.\u201d \u2014Amelia Barr","title":"Pre-Class Lesson 1: TITLE"},{"location":"module-1/pre-class-lessons/lessonOutlineTemplate/#special-elements-like-images","text":"Mkdocs and Material along with a nice extension called pym... allow for some serious control over your documentation (learning materials). Here's an example of an image aligned to the right: see it there? We can add any bit of text we want to make our ebook's flow more interestingly! Unfortunately you have to have quite a bit to say here otherwise the next sections gets caught up in here unless you can find a good solution for this!! Using HTML we can create captions And control their dimensions","title":"Special Elements like Images"},{"location":"module-1/pre-class-lessons/lessonOutlineTemplate/#and-videos","text":"Link to a video Or embed it on the screen","title":"And Videos"},{"location":"module-1/pre-class-lessons/lessonOutlineTemplate/#code-blocks-snippets","text":"Need some code fencing and annotation? Javascript 1 2 3 4 5 const myVariable = 8 const addSix = num => { return num + 6 } Python 1 2 3 4 5 6 my_variable = 8 def add_six ( num ): return num + 6 print ( add_six ( my_variable )) const addSix = num => { When we pass one and only one argument to a function declared with the const keyword we don't HAVE to wrap it with ( ) . 1 2 3 4 5 < section class = \"row gallery-two\" > <!-- Copy/Paste the line below for as many images as you'd like --> < img src = \"\" alt = \"what the image is\" height = \"360\" width = \"240\" > < img src = \"https://media.giphy.com/media/CBnvmgOvK1d9C/giphy.gif\" alt = \"what the image is\" height = \"360\" width = \"240\" > </ section > line numbers :do you like 'em? NOTE: Make sure to indent your fence block's properly.","title":"Code Blocks &amp; Snippets"},{"location":"module-1/pre-class-lessons/lessonOutlineTemplate/#in-line-code-keyboard-buttons","text":"What about some in-line code ? Like this and .bind() . Or color: , height: , width: , z-index: , font-size: ? What about keys? Ctrl + Alt + Del , Enter , Space , L , or Esc NOTE: Indent additional comments like this.","title":"In-line Code + Keyboard buttons!!"},{"location":"module-1/pre-class-lessons/lessonOutlineTemplate/#lots-of-lists","text":"You can make some really nice lists too!! Here Here Here Or share some tips way computers work way computers work way computers work bullets bullets Or share some tips way computers work way computers work way computers work bullets bullets And check out these checklists! Task One Task One.a Task Two Task Two.a Task Two.b Task Two.c Need a table? Method Description GET Fetch resource PUT Update resource DELETE Delete resource","title":"Lots of Lists"},{"location":"module-2/class-plans/classOutlineTemplate/","text":"Class #: Title Instructor Only Content - HIDE FROM STUDENTS Greet, Outline, and Objectify Today we're going to: GENERIC OBJECTIVE: By re-engaging with previously learned knowledge and applying it to a new challenge the student will deepen their understanding and be prepared to creatively reuse these techniques in new ways. GENERIC OBJECTIVE: After learning new content through individual presentations and exploring their uses with familiar tasks the student will gain confidence in their abilities to effectively solve new problems in the future. Questions for Student Led Discussion Interview Challenge Student Presentations Creation Time Push Yourself Further Exit Recap, Attendance, and Reminders Questions for Student Led Discussion, 10-15 minutes First Question: Tell me what you learned. ..? Interview Challenge, 10-15 minutes Prompt: Student Presentations, 10-15 minutes Prompt 1: Prompt 2: Creation Time, 60-90 minutes Push Yourself Further Exit Recap, Attendance, and Reminders, 5 mins","title":"Class #: Title"},{"location":"module-2/class-plans/classOutlineTemplate/#class-title","text":"","title":"Class #: Title"},{"location":"module-2/class-plans/classOutlineTemplate/#instructor-only-content-hide-from-students","text":"","title":"Instructor Only Content - HIDE FROM STUDENTS"},{"location":"module-2/class-plans/classOutlineTemplate/#greet-outline-and-objectify","text":"Today we're going to: GENERIC OBJECTIVE: By re-engaging with previously learned knowledge and applying it to a new challenge the student will deepen their understanding and be prepared to creatively reuse these techniques in new ways. GENERIC OBJECTIVE: After learning new content through individual presentations and exploring their uses with familiar tasks the student will gain confidence in their abilities to effectively solve new problems in the future. Questions for Student Led Discussion Interview Challenge Student Presentations Creation Time Push Yourself Further Exit Recap, Attendance, and Reminders","title":"Greet, Outline, and Objectify"},{"location":"module-2/class-plans/classOutlineTemplate/#questions-for-student-led-discussion-10-15-minutes","text":"First Question: Tell me what you learned. ..?","title":"Questions for Student Led Discussion, 10-15 minutes"},{"location":"module-2/class-plans/classOutlineTemplate/#interview-challenge-10-15-minutes","text":"Prompt:","title":"Interview Challenge, 10-15 minutes"},{"location":"module-2/class-plans/classOutlineTemplate/#student-presentations-10-15-minutes","text":"Prompt 1: Prompt 2:","title":"Student Presentations, 10-15 minutes"},{"location":"module-2/class-plans/classOutlineTemplate/#creation-time-60-90-minutes","text":"","title":"Creation Time, 60-90 minutes"},{"location":"module-2/class-plans/classOutlineTemplate/#push-yourself-further","text":"","title":"Push Yourself Further"},{"location":"module-2/class-plans/classOutlineTemplate/#exit-recap-attendance-and-reminders-5-mins","text":"","title":"Exit Recap, Attendance, and Reminders, 5 mins"},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/","text":"Pre-Class Lesson 1: The Internet/Web, Our Job as Developers, and Ways to Think About It How The Internet Works In this course we'll be learning how to build websites. No, not apps yet but trust that the technology used for apps is the same technology used to build website and anything you'll ever want to build in the future, is also built on the foundations we'll learn in this course..... What is the Internet? The internet is a continuous connection of various computer and devices that includes your phone, computer, watch, and doorbell. More here... How Does it Work? In order for these devices to talk to one another they must rely on a series of steps that detail how, when, and what data transfers look like. More here... Three Jobs of a Web Developer At any given point of a web developer's typical work day they are doing one these three jobs: 1 - Storing Data 2 - Moving & Manipulating Data 3 - Rendering Data Ways of Thinking The way computers work does seem like magic. more here... What Layer of Abstraction are We? Now that we've know about electrons passing through our phone screen and binary representing red actions, where are we actually developing? What level of abstraction are we working in if not in electrons or binary? In this course and the entire program, we'll be building websites and web apps that depend on the pre-determined structure of a computer and the protocol we've just learned about earlier. That structure and protocol are just two of the many layers of abstracted tools that we get to use to build! To answer the question, in web development we are working at the 10th layer of abstraction. 1st - Electrons and Transistors 2nd - DRAM memory and a CPU using binary(1s & 0s) 3rd - Bits & Bytes 4th - Logic Gates - AND, NOT, NAND, OR, XOR, ADDER 5th - Functions - small packets of instructions 6th - Operating System - computing the memory with functions 7th - Service Workers - small but massively important programs that keep your computer running smoothly 8th - Interpreters - programs used to interpret instructions from other apps into binary 9th - Browser App - an app that interprets your HTML, CSS, and JavaScript into visual elements with executable actions. 10th - HTTP, HTML, CSS, JS IT IS MOST IMPORTANT THAT YOU REALIZE YOU DON'T NEED TO UNDERSTAND THE FIRST 9 LAYERS OF ABSTRACTION! Use this list to appreciate the work many scientists and engineers have done to create the environment we are lucky to inherit and develop within AND to know that this layers of abstraction create the fundamentals of how computers operate and communicate with one another. This means that our HTML, CSS, and JS code is just following the same foundational principals of computer science. Now all that's left to do is learn to use these abstracted tools(layers) to build website and web apps! To learn and use these tools/abstractions doesn't require CS degrees or knowledge of bits, bytes, interpreters, or service workers. It only requires you to see this development world from two perspectives at the same time while keeping another idea in mind, Object Modeling. The Two Perspectives + Object Modeling Perspective One: Objects are how the computer keeps up with memory and interacts with the world and people around it? Perspective Two: We use code to organize our thoughts about how to access that memory and give instructions on what to do with that memory to both the computer and other human-beings(fellow developers). In the next session we'll explore the following questions: 1 2 * How do we accomplish the invisible task of seeing the memory of computers? * How does code represent our programming intentions to the computer? To do this we'll break them down in three parts: Objects, Object Modeling, Code as Communication. Part One: Objects Computers don't have eyes or ears...yet. Part Two: Object Modeling. Object Modeling... try it! Draw a large box nearly the size of a sheet of notebook paper. At the top label it window . Inside draw another box nearly 3/4 the size of the first box. Label this one document . > Inside the window box create two lists titled: \"Properties\" & \"Methods\" > Under the \"Properties\" list write down the first five properties you find at this website: W3S Window Object NOTICE: The 2nd property is \"Console\" and the 4th is \"Document\" These are two objects you've already come across; the \"Console\" is the one you opened in your Inspect > Developer Tools earlier and typed \"window\". And the \"Document\" is the other box on your page!! > In the \"Methods\" list write the first 5 methods you see on that same website: W3S Window Object > Repeat these steps for the smaller box, the \"Document\" object, but with this page instead: W3S Document Object NOTE: the ones with parenthesis() following them are methods and the ones without are properties. What you see on your paper is a simple model of two objects, Window and Document, and shorts lists of each of their properties and methods. This is Object Modeling. And this is how we will talk about EVERYTHING we learn. Everything is an object with properties, methods, and events. To continue on this Object Modeling exploration we'll need to cover some new terms: Properties , Methods , and Events . These three new terms are called the members of an object. Properties All objects have properties . Properties are descriptions of the object. If you were an object you would have properties that might include: name: , gender: , height: , weight: , age: , DOB: , job: . The same goes for our web page objects. All visible objects have color: , height: , width: , z-index: , font-size: , etc... Properties are things that describe what something is, what it contains, and what it looks like when rendered. You'll also see properties referred to as attributes and keys while the value that is assigned to each of them (the part after the colon and before comma) is called a value leading to the common expression: key/value pairs , i.e. name: \"Rebecca\", , age: 33, or width: 500px, Methods Most objects have methods . Methods are like special properties in that they don't describe the object but instead they describe actions the object can do! You might have methods like eat() , sleep() , run() , and beStill() . However, as you saw in your exercise, objects on our web pages might have methods like: confirm() , clearInterval() , createElement() , execCommand() and open() because they are computer object-things and not human-being things with needs like food, water, and shelter. Methods are also called built-in functions because they work like functions. They're small sets of instructions that can be executed just like other functions. Now, we haven't fully covered functions yet but suffice it to say that if you just learned how to mix cocktails you would now have two new functions written into your system that are maybe called: mixIngredients() and shakeVigoursly() . So every time you need to make a cocktail for your party you would first call mixIngredients() then shakeVigoursly() . Not everyone needs or want to learn how to make cocktails but everyone needs to eat, sleep, and drink. So the good Lord gave us all built-in functions/ methods called: sleep() , eat() , and drink() . In web development, the reason we have methods is because some functions need to be called regularly, by all developers for most apps and don't need to be special or customized. So the engineers of HTML created \"built-in functions\" that are readily available to be used by us. The \"built-in\" functions are methods . Events Most objects also have a third category of members : Events . You can think of events as interactions. Interactions that happen between objects and other objects or objects and humans. See, we can move our mouse, place our icon on an element on our screen, and click on that icon. In that single move there are three distinct events/interactions that happen: 1) onmousemove , onmouseenter , and onmousedown . The events are built into object so that they can be interacted with. We have event like: lookedAt , smiledAt , handShaked , poked , hugged , shoved , greeted . All of these are ways in which our bodies are interacted with the world around them. In web development terms, these Events are used to \"capture\" an interaction and then do something because of it. For the most part all of these built-in events are attached to a \"blank\"; in that, they fire every time the event happens but nothing is triggered. It's up to us, the developer to create reactions and then attach them to the the events. So we might say something like: onmouseenter=\"openGreetingWindow()\" . This could be equivalent to our bodies being programmed with: smiledAt=\"smileBack()\" . At this point you may be a bit confused on the difference between methods and events so for now separate them by this distinctions: 1 2 3 * Events capture interactions with the object from the outside world, in order for us to attach instructions to be carried out when the event happens. * Methods are actions the the object can take to outwardly interact with the world. * And properties are bits information that describe the object. While object modeling is a great way to understand how a computer interacts with the world it is not how we communicate to the computer our programming intentions. The computer, frankly doesn't know anything about this Object Modeling stuff. It just knows about objects because what we interpret as a \"model\" is the complete and total reality of a computer. It knows nothing else. Because of this, we have to use a language that communicates to the computer our intentions with its objects their subsequent properties, methods, and events. This language is what generally call code . The great thing about learning code now is that you've already built-thing with three different coding languages and you've been reading code in all of these textual examples. Part Three: Code as Communication. In order for us to communicate our programming needs and intentions we need a language that can be interpreted by the computer and understood by humans. This is what we call code . Code comes in many different names and flavors that we call languages, or programming languages . We use programming languages to communicate to both humans and computers what our programming needs and intentions are. Notice earlier, we used the word \"interpret\" for computers and \"understand\" for humans. This is because, as long as your fellow developers know the syntax and semantics of the language you chose to write, they will understand what you meant. But the computer must \"interpret\" what you wrote because the computer doesn't actually know JavaScript from Closure or Haskell. Our computers use interpreters that convert your programming language of choice to binary before it executes the program you built. Programming languages are similar to our human languages in that they were all created to represent and communicate our needs and intentions. It doesn't matter what language you are speaking...as long as you are speaking to someone who understands the language they will know what you're saying. This goes for computers as well. When we're building websites and web app we're talking to web browsers who know three languages: HTML, JS, and CSS. If we are building iOS apps we're talking to an operating system that understands Swift and if we're build apps for Android we're talking to a system that understands Java. All languages are built in similar ways because they all have to accomplish the same goals: store data, move data, and render data. In this way, you can feel confident that once you now how to program in JavaScript, learning to program with Python, Swift, Java, Go, or C# will come much easier! This layer of \"abstraction\" is not so important for us to learn, so much, as it is helpful for us to understand that programming languages like JavaScript are just languages with nouns, verbs, sentence structure, actions, and objects that all represent to the computer our programming needs and intention of how to we would like to move, manipulate, and display the objects our computers know about. In Summary: Our Three Jobs, Object Modeling & Code as Communication Now that we've learned our three jobs as web developers are to store, move, and render data inside an invisible world with 10 levels of abstractions with a computer that see only objects with properties, methods, & events and interprets only code it recognizes we have our work cut out for us. How do we do it? We first have to remember that our three jobs as web developers is to store data, move data, and render data. The next is to always draw out our objects on paper, whiteboard and in our mind so we don't forget that everything is an object. Third, we have to practice gratitude for the languages we get to learn and be happy that we get to create stories and books with these programming languages instead of new words for every thought. After that, we must always reference our docs. Docs are how to learn and remember object, properties, methods, and events . And lastly, we have to keep learning and trusting that we can do this!","title":"Pre-Class Lesson 1: The Internet/Web, Our Job as Developers, and Ways to Think About It"},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#pre-class-lesson-1-the-internetweb-our-job-as-developers-and-ways-to-think-about-it","text":"","title":"Pre-Class Lesson 1: The Internet/Web, Our Job as Developers, and Ways to Think About It"},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#how-the-internet-works","text":"In this course we'll be learning how to build websites. No, not apps yet but trust that the technology used for apps is the same technology used to build website and anything you'll ever want to build in the future, is also built on the foundations we'll learn in this course.....","title":"How The Internet Works"},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#what-is-the-internet","text":"The internet is a continuous connection of various computer and devices that includes your phone, computer, watch, and doorbell. More here...","title":"What is the Internet?"},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#how-does-it-work","text":"In order for these devices to talk to one another they must rely on a series of steps that detail how, when, and what data transfers look like. More here...","title":"How Does it Work?"},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#three-jobs-of-a-web-developer","text":"At any given point of a web developer's typical work day they are doing one these three jobs: 1 - Storing Data 2 - Moving & Manipulating Data 3 - Rendering Data","title":"Three Jobs of a Web Developer"},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#ways-of-thinking","text":"The way computers work does seem like magic. more here...","title":"Ways of Thinking"},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#what-layer-of-abstraction-are-we","text":"Now that we've know about electrons passing through our phone screen and binary representing red actions, where are we actually developing? What level of abstraction are we working in if not in electrons or binary? In this course and the entire program, we'll be building websites and web apps that depend on the pre-determined structure of a computer and the protocol we've just learned about earlier. That structure and protocol are just two of the many layers of abstracted tools that we get to use to build! To answer the question, in web development we are working at the 10th layer of abstraction. 1st - Electrons and Transistors 2nd - DRAM memory and a CPU using binary(1s & 0s) 3rd - Bits & Bytes 4th - Logic Gates - AND, NOT, NAND, OR, XOR, ADDER 5th - Functions - small packets of instructions 6th - Operating System - computing the memory with functions 7th - Service Workers - small but massively important programs that keep your computer running smoothly 8th - Interpreters - programs used to interpret instructions from other apps into binary 9th - Browser App - an app that interprets your HTML, CSS, and JavaScript into visual elements with executable actions. 10th - HTTP, HTML, CSS, JS IT IS MOST IMPORTANT THAT YOU REALIZE YOU DON'T NEED TO UNDERSTAND THE FIRST 9 LAYERS OF ABSTRACTION! Use this list to appreciate the work many scientists and engineers have done to create the environment we are lucky to inherit and develop within AND to know that this layers of abstraction create the fundamentals of how computers operate and communicate with one another. This means that our HTML, CSS, and JS code is just following the same foundational principals of computer science. Now all that's left to do is learn to use these abstracted tools(layers) to build website and web apps! To learn and use these tools/abstractions doesn't require CS degrees or knowledge of bits, bytes, interpreters, or service workers. It only requires you to see this development world from two perspectives at the same time while keeping another idea in mind, Object Modeling.","title":"What Layer of Abstraction are We?"},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#the-two-perspectives-object-modeling","text":"Perspective One: Objects are how the computer keeps up with memory and interacts with the world and people around it? Perspective Two: We use code to organize our thoughts about how to access that memory and give instructions on what to do with that memory to both the computer and other human-beings(fellow developers). In the next session we'll explore the following questions: 1 2 * How do we accomplish the invisible task of seeing the memory of computers? * How does code represent our programming intentions to the computer? To do this we'll break them down in three parts: Objects, Object Modeling, Code as Communication.","title":"The Two Perspectives + Object Modeling"},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#part-one-objects","text":"Computers don't have eyes or ears...yet.","title":"Part One: Objects"},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#part-two-object-modeling","text":"Object Modeling... try it! Draw a large box nearly the size of a sheet of notebook paper. At the top label it window . Inside draw another box nearly 3/4 the size of the first box. Label this one document . > Inside the window box create two lists titled: \"Properties\" & \"Methods\" > Under the \"Properties\" list write down the first five properties you find at this website: W3S Window Object NOTICE: The 2nd property is \"Console\" and the 4th is \"Document\" These are two objects you've already come across; the \"Console\" is the one you opened in your Inspect > Developer Tools earlier and typed \"window\". And the \"Document\" is the other box on your page!! > In the \"Methods\" list write the first 5 methods you see on that same website: W3S Window Object > Repeat these steps for the smaller box, the \"Document\" object, but with this page instead: W3S Document Object NOTE: the ones with parenthesis() following them are methods and the ones without are properties. What you see on your paper is a simple model of two objects, Window and Document, and shorts lists of each of their properties and methods. This is Object Modeling. And this is how we will talk about EVERYTHING we learn. Everything is an object with properties, methods, and events. To continue on this Object Modeling exploration we'll need to cover some new terms: Properties , Methods , and Events . These three new terms are called the members of an object.","title":"Part Two: Object Modeling."},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#properties","text":"All objects have properties . Properties are descriptions of the object. If you were an object you would have properties that might include: name: , gender: , height: , weight: , age: , DOB: , job: . The same goes for our web page objects. All visible objects have color: , height: , width: , z-index: , font-size: , etc... Properties are things that describe what something is, what it contains, and what it looks like when rendered. You'll also see properties referred to as attributes and keys while the value that is assigned to each of them (the part after the colon and before comma) is called a value leading to the common expression: key/value pairs , i.e. name: \"Rebecca\", , age: 33, or width: 500px,","title":"Properties"},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#methods","text":"Most objects have methods . Methods are like special properties in that they don't describe the object but instead they describe actions the object can do! You might have methods like eat() , sleep() , run() , and beStill() . However, as you saw in your exercise, objects on our web pages might have methods like: confirm() , clearInterval() , createElement() , execCommand() and open() because they are computer object-things and not human-being things with needs like food, water, and shelter. Methods are also called built-in functions because they work like functions. They're small sets of instructions that can be executed just like other functions. Now, we haven't fully covered functions yet but suffice it to say that if you just learned how to mix cocktails you would now have two new functions written into your system that are maybe called: mixIngredients() and shakeVigoursly() . So every time you need to make a cocktail for your party you would first call mixIngredients() then shakeVigoursly() . Not everyone needs or want to learn how to make cocktails but everyone needs to eat, sleep, and drink. So the good Lord gave us all built-in functions/ methods called: sleep() , eat() , and drink() . In web development, the reason we have methods is because some functions need to be called regularly, by all developers for most apps and don't need to be special or customized. So the engineers of HTML created \"built-in functions\" that are readily available to be used by us. The \"built-in\" functions are methods .","title":"Methods"},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#events","text":"Most objects also have a third category of members : Events . You can think of events as interactions. Interactions that happen between objects and other objects or objects and humans. See, we can move our mouse, place our icon on an element on our screen, and click on that icon. In that single move there are three distinct events/interactions that happen: 1) onmousemove , onmouseenter , and onmousedown . The events are built into object so that they can be interacted with. We have event like: lookedAt , smiledAt , handShaked , poked , hugged , shoved , greeted . All of these are ways in which our bodies are interacted with the world around them. In web development terms, these Events are used to \"capture\" an interaction and then do something because of it. For the most part all of these built-in events are attached to a \"blank\"; in that, they fire every time the event happens but nothing is triggered. It's up to us, the developer to create reactions and then attach them to the the events. So we might say something like: onmouseenter=\"openGreetingWindow()\" . This could be equivalent to our bodies being programmed with: smiledAt=\"smileBack()\" . At this point you may be a bit confused on the difference between methods and events so for now separate them by this distinctions: 1 2 3 * Events capture interactions with the object from the outside world, in order for us to attach instructions to be carried out when the event happens. * Methods are actions the the object can take to outwardly interact with the world. * And properties are bits information that describe the object. While object modeling is a great way to understand how a computer interacts with the world it is not how we communicate to the computer our programming intentions. The computer, frankly doesn't know anything about this Object Modeling stuff. It just knows about objects because what we interpret as a \"model\" is the complete and total reality of a computer. It knows nothing else. Because of this, we have to use a language that communicates to the computer our intentions with its objects their subsequent properties, methods, and events. This language is what generally call code . The great thing about learning code now is that you've already built-thing with three different coding languages and you've been reading code in all of these textual examples.","title":"Events"},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#part-three-code-as-communication","text":"In order for us to communicate our programming needs and intentions we need a language that can be interpreted by the computer and understood by humans. This is what we call code . Code comes in many different names and flavors that we call languages, or programming languages . We use programming languages to communicate to both humans and computers what our programming needs and intentions are. Notice earlier, we used the word \"interpret\" for computers and \"understand\" for humans. This is because, as long as your fellow developers know the syntax and semantics of the language you chose to write, they will understand what you meant. But the computer must \"interpret\" what you wrote because the computer doesn't actually know JavaScript from Closure or Haskell. Our computers use interpreters that convert your programming language of choice to binary before it executes the program you built. Programming languages are similar to our human languages in that they were all created to represent and communicate our needs and intentions. It doesn't matter what language you are speaking...as long as you are speaking to someone who understands the language they will know what you're saying. This goes for computers as well. When we're building websites and web app we're talking to web browsers who know three languages: HTML, JS, and CSS. If we are building iOS apps we're talking to an operating system that understands Swift and if we're build apps for Android we're talking to a system that understands Java. All languages are built in similar ways because they all have to accomplish the same goals: store data, move data, and render data. In this way, you can feel confident that once you now how to program in JavaScript, learning to program with Python, Swift, Java, Go, or C# will come much easier! This layer of \"abstraction\" is not so important for us to learn, so much, as it is helpful for us to understand that programming languages like JavaScript are just languages with nouns, verbs, sentence structure, actions, and objects that all represent to the computer our programming needs and intention of how to we would like to move, manipulate, and display the objects our computers know about.","title":"Part Three: Code as Communication."},{"location":"module-2/pre-class-lessons/lessonOutlineTemplate/#in-summary-our-three-jobs-object-modeling-code-as-communication","text":"Now that we've learned our three jobs as web developers are to store, move, and render data inside an invisible world with 10 levels of abstractions with a computer that see only objects with properties, methods, & events and interprets only code it recognizes we have our work cut out for us. How do we do it? We first have to remember that our three jobs as web developers is to store data, move data, and render data. The next is to always draw out our objects on paper, whiteboard and in our mind so we don't forget that everything is an object. Third, we have to practice gratitude for the languages we get to learn and be happy that we get to create stories and books with these programming languages instead of new words for every thought. After that, we must always reference our docs. Docs are how to learn and remember object, properties, methods, and events . And lastly, we have to keep learning and trusting that we can do this!","title":"In Summary: Our Three Jobs, Object Modeling &amp; Code as Communication"},{"location":"preCourse/codingAndProgramming/","text":"Coding & Programming Programming is the process of solving a problem. Coding is the process of communicating that solution for the computer to execute. Programming For the sake of the class I want you to think of programming as figuring out the steps of a process(program) and telling the computer in a very detailed, non-ambiguous way how to execute the steps in the process(program). In this way, you're looking at a problem from a higher point-of-view using your vision, hearing and even touch to figure out solutions to the problem and then to implement a process of steps whereby to arrive at the solution. For instance: A Simple Program Example Given a list of numbers: 2, 5, 6, 7 and 9, add 1 to each number and return a list of the new values and the sum of all of those new values Perfect! Let's walk through this step by step to see how we might program a solution to this problem. Our given input is [2, 5, 6, 7, 9] . We have the first action: add 1 to each number in the list. A second action: return the list of new numbers. And we have a third action: return the sum of the new list of numbers! We can even deduce another piece of the puzzle: If our input is a list of numbers like: [2, 5, 6, 7, 9] into our program, our expect output will be [3, 6, 7, 8, 10] with a sum value of 34 . Now that we know what our program's actions(steps) are and what the expected output or our program should be we can begin to reverse-engineer the solution. Action 1: add 1 to each number tell the computer to loop though the list of numbers and for each number add 1 to its value Action 2: return the list of new numbers collect the new values in another list [ ]in the return statement include the new list Action 3: Return the sum of the new list hold the value of the new numbers in a place in the return statement include the place you were holding sum of new numbers Hopefully, you can see now how we can approach any problem. We begin with a bigger view of the problem and work our way down to the small details of it. In this way we use our natural human ability to solve complex problems with mental models and abstraction then list them into short, clear directives to give to the computer. And this, for our purposes, is programming. We have been given a challenge and we found a solution and listed out the steps needed to make it a process. From here we can translate(code) it into any language we want: C, C++, C#, Python, Swift, Rust, Go, Dart, Java, Erlang, or Cobol. In the next section, we're going to translate(code)these steps into Javascript. What is Coding? As you just saw, programming is listing out all the steps a program will need to accomplish a task given by a human so that it can return an expected result. Coding , on the other hand, is the language we use to communicate to other humans our intent for a computer's task while also telling the computer what we expect it to repeat over and over in a precise and predictable way. It is also important to note that no coding language is actually what the computer reads. All languages are compiled down to binary , the language a computer can understand. Therefore, you could use nearly any language you want to accomplish most tasks. There are restrictions, of course (i.e. all front-end apps have to be written in JS), preferences (Python for analytics), and logistical things (full coverage testing, support, open-source, and technical cost) to consider but keep in mind, the characters ( tokens you type into the text editor) are not really read by the computer the same way you see them on the screen. Now we're going to turn those programming steps from the last section into JavaScript code so that a computer can complete the tasks we created for it. Below are the instructions we wrote out while learning to program , next to code that describes the action steps in JavaScript code. You'll see //comments in the code that describe what's happening But, STOP , create a new Repl.it and follow along! ...SERIOUSLY!! Simple Coding Example Before we can perform Action 1, let's build a function (program/process) we can call to do something at some point. Let's call it: addOneWithSum 1 2 3 const addOneWithSum = () => { } Then let's make sure it can take in an array of numbers like the one given to us in the example above: const exampleArray = [2, 5, 6, 7, 9] 1 2 3 const addOneWithSum = ( ourArray ) => { } Now let's do Action 1: add 1 to each number 1 2 3 4 5 6 7 8 9 10 11 12 13 const addOneWithSum = ( ourArray ) => { // tell the computer to loop though the list of numbers and for each number add 1 to its value for ( let i = 0 ; i < ourArray . length ; i ++ ) { ourArray [ i ] + 1 } } // More details: // the for() loop states: // let i = 0; - set i to 0, (i stands for iterator) // i < ourArray.length; - and while i is less than the length of ourArray keep doing what is inside the code block // i++ - and each time you loop through ourArray once add 1 to the value of i so that we keep iterating through all of the numbers in the list. // ourArray[i] + 1 - inside the {} of the for() loop we add 1 to each item in ourArray Action 2: return the list of new numbers 1 2 3 4 5 6 7 8 9 10 11 12 13 const addOneWithSum = ( ourArray ) => { // collect the new values in another list(array) let newList = [] for ( let i = 0 ; i < ourArray . length ; i ++ ) { newList . push ( ourArray [ i ] + 1 ) } // in the return statement include the new list return newList } // let newList = [] - creates a place we can hold the new values of the list // newList.push(ourArray[i] + 1) - the .push() method pushes the new values into the newList array/list // return newList - and then we returned the newList as the output of this program Action 3: Return the sum of the new list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const addOneWithSum = ( ourArray ) => { let newList = [] // hold the value of the new numbers in a place/variable let sum = 0 for ( let i = 0 ; i < ourArray . length ; i ++ ) { sum += ( ourArray [ i ] + 1 ) newList . push ( ourArray [ i ] + 1 ) } // in the return statement include the place you were holding sum of new numbers return newList + ' ' + sum } // let sum = 0 - Now we create a place to hold the sum of the new numbers: sum // sum += (ourArray[i] + 1) - and inside our for() loop we continually add to the value of sum // then we return sum as part of our output. // in the return we added a space, ' ' , between newList and sum so that the return would be easier to read. The final step to this is to feed our function(program) the input and call our newly built function(program): 1 2 3 4 5 6 7 8 9 10 11 12 13 const exampleArray = [ 2 , 5 , 6 , 7 , 9 ] const addOneWithSum = ( ourArray ) => { let newList = [] let sum = 0 for ( let i = 0 ; i < ourArray . length ; i ++ ) { sum += ( ourArray [ i ] + 1 ) newList . push ( ourArray [ i ] + 1 ) } return newList + ' ' + sum } addOneWithSum ( exampleArray ) Practice It Throw this code into a repl.it and practice for yourself! Solve this problem: given an array of numbers: [2, 4, 6, 8, 10], divide each number by two, return the new array and the product (multiplied all together) of the new array. Continue reading about the differences btw coding vs programming . Summary A deciding factor in your success with programming is your ability to think critically about how to solve problems. After all, that's really what we do as engineers; whether we're building software or designing rocket ships\u2014we solve problems. To ensure your success as a web developer, our hope is not just that you learn how to code, but that you develop the skills necessary to be an effective problem-solver. The latter is arguably more important when it comes down to what will get you hired. With that in mind, consider this section as your first lesson in fundamental programming concepts, as well as a guided tour of the kind of thinking we'd like we need you to practice as you move forward in the course. Programming and problem-solving go hand in hand\u2014so long as you practice, ask questions and seek answers, you'll develop proficiency with both skill sets.","title":"Coding + Programming"},{"location":"preCourse/codingAndProgramming/#coding-programming","text":"Programming is the process of solving a problem. Coding is the process of communicating that solution for the computer to execute.","title":"Coding &amp; Programming"},{"location":"preCourse/codingAndProgramming/#programming","text":"For the sake of the class I want you to think of programming as figuring out the steps of a process(program) and telling the computer in a very detailed, non-ambiguous way how to execute the steps in the process(program). In this way, you're looking at a problem from a higher point-of-view using your vision, hearing and even touch to figure out solutions to the problem and then to implement a process of steps whereby to arrive at the solution. For instance:","title":"Programming"},{"location":"preCourse/codingAndProgramming/#a-simple-program-example","text":"Given a list of numbers: 2, 5, 6, 7 and 9, add 1 to each number and return a list of the new values and the sum of all of those new values Perfect! Let's walk through this step by step to see how we might program a solution to this problem. Our given input is [2, 5, 6, 7, 9] . We have the first action: add 1 to each number in the list. A second action: return the list of new numbers. And we have a third action: return the sum of the new list of numbers! We can even deduce another piece of the puzzle: If our input is a list of numbers like: [2, 5, 6, 7, 9] into our program, our expect output will be [3, 6, 7, 8, 10] with a sum value of 34 . Now that we know what our program's actions(steps) are and what the expected output or our program should be we can begin to reverse-engineer the solution. Action 1: add 1 to each number tell the computer to loop though the list of numbers and for each number add 1 to its value Action 2: return the list of new numbers collect the new values in another list [ ]in the return statement include the new list Action 3: Return the sum of the new list hold the value of the new numbers in a place in the return statement include the place you were holding sum of new numbers Hopefully, you can see now how we can approach any problem. We begin with a bigger view of the problem and work our way down to the small details of it. In this way we use our natural human ability to solve complex problems with mental models and abstraction then list them into short, clear directives to give to the computer. And this, for our purposes, is programming. We have been given a challenge and we found a solution and listed out the steps needed to make it a process. From here we can translate(code) it into any language we want: C, C++, C#, Python, Swift, Rust, Go, Dart, Java, Erlang, or Cobol. In the next section, we're going to translate(code)these steps into Javascript.","title":"A Simple Program Example"},{"location":"preCourse/codingAndProgramming/#what-is-coding","text":"As you just saw, programming is listing out all the steps a program will need to accomplish a task given by a human so that it can return an expected result. Coding , on the other hand, is the language we use to communicate to other humans our intent for a computer's task while also telling the computer what we expect it to repeat over and over in a precise and predictable way. It is also important to note that no coding language is actually what the computer reads. All languages are compiled down to binary , the language a computer can understand. Therefore, you could use nearly any language you want to accomplish most tasks. There are restrictions, of course (i.e. all front-end apps have to be written in JS), preferences (Python for analytics), and logistical things (full coverage testing, support, open-source, and technical cost) to consider but keep in mind, the characters ( tokens you type into the text editor) are not really read by the computer the same way you see them on the screen. Now we're going to turn those programming steps from the last section into JavaScript code so that a computer can complete the tasks we created for it. Below are the instructions we wrote out while learning to program , next to code that describes the action steps in JavaScript code. You'll see //comments in the code that describe what's happening But, STOP , create a new Repl.it and follow along! ...SERIOUSLY!!","title":"What is Coding?"},{"location":"preCourse/codingAndProgramming/#simple-coding-example","text":"Before we can perform Action 1, let's build a function (program/process) we can call to do something at some point. Let's call it: addOneWithSum 1 2 3 const addOneWithSum = () => { } Then let's make sure it can take in an array of numbers like the one given to us in the example above: const exampleArray = [2, 5, 6, 7, 9] 1 2 3 const addOneWithSum = ( ourArray ) => { } Now let's do Action 1: add 1 to each number 1 2 3 4 5 6 7 8 9 10 11 12 13 const addOneWithSum = ( ourArray ) => { // tell the computer to loop though the list of numbers and for each number add 1 to its value for ( let i = 0 ; i < ourArray . length ; i ++ ) { ourArray [ i ] + 1 } } // More details: // the for() loop states: // let i = 0; - set i to 0, (i stands for iterator) // i < ourArray.length; - and while i is less than the length of ourArray keep doing what is inside the code block // i++ - and each time you loop through ourArray once add 1 to the value of i so that we keep iterating through all of the numbers in the list. // ourArray[i] + 1 - inside the {} of the for() loop we add 1 to each item in ourArray Action 2: return the list of new numbers 1 2 3 4 5 6 7 8 9 10 11 12 13 const addOneWithSum = ( ourArray ) => { // collect the new values in another list(array) let newList = [] for ( let i = 0 ; i < ourArray . length ; i ++ ) { newList . push ( ourArray [ i ] + 1 ) } // in the return statement include the new list return newList } // let newList = [] - creates a place we can hold the new values of the list // newList.push(ourArray[i] + 1) - the .push() method pushes the new values into the newList array/list // return newList - and then we returned the newList as the output of this program Action 3: Return the sum of the new list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const addOneWithSum = ( ourArray ) => { let newList = [] // hold the value of the new numbers in a place/variable let sum = 0 for ( let i = 0 ; i < ourArray . length ; i ++ ) { sum += ( ourArray [ i ] + 1 ) newList . push ( ourArray [ i ] + 1 ) } // in the return statement include the place you were holding sum of new numbers return newList + ' ' + sum } // let sum = 0 - Now we create a place to hold the sum of the new numbers: sum // sum += (ourArray[i] + 1) - and inside our for() loop we continually add to the value of sum // then we return sum as part of our output. // in the return we added a space, ' ' , between newList and sum so that the return would be easier to read. The final step to this is to feed our function(program) the input and call our newly built function(program): 1 2 3 4 5 6 7 8 9 10 11 12 13 const exampleArray = [ 2 , 5 , 6 , 7 , 9 ] const addOneWithSum = ( ourArray ) => { let newList = [] let sum = 0 for ( let i = 0 ; i < ourArray . length ; i ++ ) { sum += ( ourArray [ i ] + 1 ) newList . push ( ourArray [ i ] + 1 ) } return newList + ' ' + sum } addOneWithSum ( exampleArray )","title":"Simple Coding Example"},{"location":"preCourse/codingAndProgramming/#practice-it","text":"Throw this code into a repl.it and practice for yourself! Solve this problem: given an array of numbers: [2, 4, 6, 8, 10], divide each number by two, return the new array and the product (multiplied all together) of the new array. Continue reading about the differences btw coding vs programming .","title":"Practice It"},{"location":"preCourse/codingAndProgramming/#summary","text":"A deciding factor in your success with programming is your ability to think critically about how to solve problems. After all, that's really what we do as engineers; whether we're building software or designing rocket ships\u2014we solve problems. To ensure your success as a web developer, our hope is not just that you learn how to code, but that you develop the skills necessary to be an effective problem-solver. The latter is arguably more important when it comes down to what will get you hired. With that in mind, consider this section as your first lesson in fundamental programming concepts, as well as a guided tour of the kind of thinking we'd like we need you to practice as you move forward in the course. Programming and problem-solving go hand in hand\u2014so long as you practice, ask questions and seek answers, you'll develop proficiency with both skill sets.","title":"Summary"},{"location":"preCourse/es5%26es6/","text":"ES5 vs ES6 Coding languages are standardized and maintained by groups or councils of people that work with and listen to the developers that use the language. Therefore languages are updated and improved periodically. JavaScript is no different. In fact, it may be one of the most rapidly improved and frequently changed languages. The body of people that maintain JavaScript is called the ECMA-262 which is overseen by the the ECMA International . The ECMA-262 made its first edition in 1997 and its latest edition came out in June 2018: ES2018 (ES9). The reason we're talking about ES6 and not ES9 here is that ES6 was the biggest renovation of the language and is now the standard of the language used across multiple platforms. While there are newer features in the newer editions it is important to remember that the engines that run JavaScript, like Chrome V8 JS Engine , have to all be updated for these newer features, so each platform can talk back and forth to one another. This process takes time so the official edition of the language in use is always a few years behind where the latest edition actually is. Note on transpiling(sic) from Wikipedia : Since ES 2015, transpiling JavaScript has become very common. Transpilation is a source to source compilation in which the newer versions of JavaScript are used in the user's source code and the transpiler rewrites them so that they are compliant with the current specification. Usually, transpilers transpile down to ES3 to maintain compatibility with all versions of browsers. The settings to transpiling to a specific version can be configured according to need. Transpiling adds an extra step to the build process and is sometimes done to avoid needing polyfills. Polyfills allow adding extra functionalities by including another JavaScript file which adds those specific functionalities. That said you should keep abreast of the recent changes in the languages you write so that you can utilize the fun new features!! So, as you learn in the course, watch videos and read blogs by other developers. They'll give you free information to use as you want. NOTE: The image below describes another reason we use Chrome as our default browser. Notice the conformance percentage for later versions of JS (ECMA). ES5 vs ES6: How The code snippets below both declare a function called imAFunction and take in a argument called content ES2011 (ES5): 1 2 3 4 // hold a function as the value of a variable. Takes one argument: `parameter` var imAFunction = function ( parameter ) { // Do stuff here } ES2015 (ES6): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // same thing, taking one argument const imAFunction = parameter => { // Do stuff here } // function taking two arguments const imAFunction2 = ( parameter , parameter2 ) => { // Do stuff here } // function taking no arguments const imAFunction3 = () => { // Do stuff here } The code snippets below all create the same variable, myVariable : Pre-ES2015 1 var myVariable = 10 ; ES2015 1 2 3 4 5 let myVariable = 10 const myVariable2 = 10 // use `let` if you expect the variable to change // use `const` if you expect the variable to be a constant value See It - Let, Const, Var Fat Arrow Syntax () => {} Additional Resources FunFunFunction - Fat Arrow Function NOTE: Don't get caught up on .filter() , .map() or .reduce() . These are really powerful built-in methods we will cover in-depth later on, together in class.","title":"ES5 vs ES6"},{"location":"preCourse/es5%26es6/#es5-vs-es6","text":"Coding languages are standardized and maintained by groups or councils of people that work with and listen to the developers that use the language. Therefore languages are updated and improved periodically. JavaScript is no different. In fact, it may be one of the most rapidly improved and frequently changed languages. The body of people that maintain JavaScript is called the ECMA-262 which is overseen by the the ECMA International . The ECMA-262 made its first edition in 1997 and its latest edition came out in June 2018: ES2018 (ES9). The reason we're talking about ES6 and not ES9 here is that ES6 was the biggest renovation of the language and is now the standard of the language used across multiple platforms. While there are newer features in the newer editions it is important to remember that the engines that run JavaScript, like Chrome V8 JS Engine , have to all be updated for these newer features, so each platform can talk back and forth to one another. This process takes time so the official edition of the language in use is always a few years behind where the latest edition actually is. Note on transpiling(sic) from Wikipedia : Since ES 2015, transpiling JavaScript has become very common. Transpilation is a source to source compilation in which the newer versions of JavaScript are used in the user's source code and the transpiler rewrites them so that they are compliant with the current specification. Usually, transpilers transpile down to ES3 to maintain compatibility with all versions of browsers. The settings to transpiling to a specific version can be configured according to need. Transpiling adds an extra step to the build process and is sometimes done to avoid needing polyfills. Polyfills allow adding extra functionalities by including another JavaScript file which adds those specific functionalities. That said you should keep abreast of the recent changes in the languages you write so that you can utilize the fun new features!! So, as you learn in the course, watch videos and read blogs by other developers. They'll give you free information to use as you want. NOTE: The image below describes another reason we use Chrome as our default browser. Notice the conformance percentage for later versions of JS (ECMA).","title":"ES5 vs ES6"},{"location":"preCourse/es5%26es6/#es5-vs-es6-how","text":"The code snippets below both declare a function called imAFunction and take in a argument called content ES2011 (ES5): 1 2 3 4 // hold a function as the value of a variable. Takes one argument: `parameter` var imAFunction = function ( parameter ) { // Do stuff here } ES2015 (ES6): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // same thing, taking one argument const imAFunction = parameter => { // Do stuff here } // function taking two arguments const imAFunction2 = ( parameter , parameter2 ) => { // Do stuff here } // function taking no arguments const imAFunction3 = () => { // Do stuff here } The code snippets below all create the same variable, myVariable : Pre-ES2015 1 var myVariable = 10 ; ES2015 1 2 3 4 5 let myVariable = 10 const myVariable2 = 10 // use `let` if you expect the variable to change // use `const` if you expect the variable to be a constant value","title":"ES5 vs ES6: How"},{"location":"preCourse/es5%26es6/#see-it-let-const-var","text":"","title":"See It - Let, Const, Var"},{"location":"preCourse/es5%26es6/#fat-arrow-syntax","text":"","title":"Fat Arrow Syntax () =&gt; {}"},{"location":"preCourse/es5%26es6/#additional-resources","text":"FunFunFunction - Fat Arrow Function NOTE: Don't get caught up on .filter() , .map() or .reduce() . These are really powerful built-in methods we will cover in-depth later on, together in class.","title":"Additional Resources"},{"location":"preCourse/firstRepo/","text":"Date & Time Repo Go to your devFolder or create a new folder to work in like JS211-Projects or something: mkdir JS211-Projects Fork this repo Clone it: git clone https://github.com/AustinCodingAcademy/JS211_CurrentDateTimeProject.git C hange D irectories into this new folder cd JS211_CurrentDateTimeProject You can check to make sure you're in the right directory by running one of the following commands: > Apple - pwd (print working directory) > Windows - echo %cd% > After hitting enter you should see \"JS211_CurrentDateTimeProject\" return on your command-line. I nstall dependencies: npm i This N ode P ackage M anager tool came with the Node software you downloaded earlier. Now open the folder up in VS Code by typing code . + Enter Tutorial to setup Path shortcut in Macs Go to the README.md and follow the directions Optional: you can first start building your solutions in a new Repl.it before adding them to the main.js file. This sometimes make for faster development time","title":"Date & Time Repo"},{"location":"preCourse/firstRepo/#date-time-repo","text":"Go to your devFolder or create a new folder to work in like JS211-Projects or something: mkdir JS211-Projects Fork this repo Clone it: git clone https://github.com/AustinCodingAcademy/JS211_CurrentDateTimeProject.git C hange D irectories into this new folder cd JS211_CurrentDateTimeProject You can check to make sure you're in the right directory by running one of the following commands: > Apple - pwd (print working directory) > Windows - echo %cd% > After hitting enter you should see \"JS211_CurrentDateTimeProject\" return on your command-line. I nstall dependencies: npm i This N ode P ackage M anager tool came with the Node software you downloaded earlier. Now open the folder up in VS Code by typing code . + Enter Tutorial to setup Path shortcut in Macs Go to the README.md and follow the directions Optional: you can first start building your solutions in a new Repl.it before adding them to the main.js file. This sometimes make for faster development time","title":"Date &amp; Time Repo"},{"location":"preCourse/historyOfJavaScript/","text":"A VERY Brief History of JavaScript Taken from A Brief History of JavaScript written by Sebastian Peyrott at Auth0. Be sure to read the bullet points, they could help you in an interview someday... May-Dec 1995 Netscape Communicator and NCSA Mosaic were the first popular web browsers. Netscape was founded by the same people that built Mosaic, but now had money and time to build it better. Marc Andreessen, founder of Netscape Communications wanted the web to become more dynamic. Animations, interaction and other forms of small automation should be part of the web of the future. To do that they would need a small scripting language that could interact with the Document Object Model (DOM) (which was not set in stone as it is right now). And it should be accessible to non-developers, better yet for designers the way HTML already was. And so the idea of Mocha was born. Mocha was to become a scripting language for the web. Simple, dynamic, and accessible to non-developers. Brendan Eich , father of JavaScript, was contracted by Netscape Communications to develop a \"Scheme for the browser\". This Scheme was to be dynamic, powerful, and functional in nature, easy to grasp syntactically and to reduce verbosity and speed up development. There was a lot of pressure to come up with a working prototype as soon as possible. The Java (not JS!) language was starting to get traction. Sun Microsystems was making a big push for it and Netscape Communications was about to close a deal with them to make Java available in the browser. Enter a new language, Mocha. The idea at the time was that Java was not suited for the type of audience that would consume Mocha: Scripters, amateurs, designers. Java was just too big, too enterprisy (sic) for the role. There was a lot of internal pressure to pick one language as soon as possible. Python , Tcl and Scheme itself were all possible candidates. So Eich had to work fast. May 1995 - Eich had the luxury to choose features but had little time to build the language. In a matter of weeks, a working prototype was integrated into Netscape Communicator in May 1995. In the end, a Java-like syntax was required, and familiar semantics for many common idioms was also adopted. So Mocha was not like Scheme at all. It looked like a dynamic Java, but underneath it was a very different beast: a premature lovechild of Scheme and Self , with Java looks. Mocha was renamed to LiveScript . And later when Sun and Netscape closed the deal it was renamed JavaScript, a scripting language for small client-side tasks. Java would be promoted as a bigger, professional tool to develop rich web components. This first version of JavaScript set in stone many of the traits the language is known for today. In particular, its object-model , and its functional features were already present in this first version. August 1996 - At the moment (and for a very long time), web standards were not strong. So Microsoft implemented its own version of JavaScript, called JScript. JScript was different in more than just name. Slight differences in implementation, in particular with regards to certain DOM functions, caused ripples that would still be felt many years into the future. JavaScript wars were fought in more fronts than just names and timelines and many of its quirks are just the wounds of these wars. The first version of JScript was included with Internet Explorer 3.0, released in August 1996. In the fall of 1996, Eich rewrote most of Mocha into a cleaner implementation to pay off for the technical debt caused by rushing it out of the door. This new version of Netscape's JavaScript engine was called SpiderMonkey . SpiderMonkey is still the name of the JavaScript engine found in Firefox, Netscape Navigator's grandson. For the full article, that link again is A Brief History of JavaScript .","title":"History of JavaScript"},{"location":"preCourse/historyOfJavaScript/#a-very-brief-history-of-javascript","text":"Taken from A Brief History of JavaScript written by Sebastian Peyrott at Auth0. Be sure to read the bullet points, they could help you in an interview someday... May-Dec 1995 Netscape Communicator and NCSA Mosaic were the first popular web browsers. Netscape was founded by the same people that built Mosaic, but now had money and time to build it better. Marc Andreessen, founder of Netscape Communications wanted the web to become more dynamic. Animations, interaction and other forms of small automation should be part of the web of the future. To do that they would need a small scripting language that could interact with the Document Object Model (DOM) (which was not set in stone as it is right now). And it should be accessible to non-developers, better yet for designers the way HTML already was. And so the idea of Mocha was born. Mocha was to become a scripting language for the web. Simple, dynamic, and accessible to non-developers. Brendan Eich , father of JavaScript, was contracted by Netscape Communications to develop a \"Scheme for the browser\". This Scheme was to be dynamic, powerful, and functional in nature, easy to grasp syntactically and to reduce verbosity and speed up development. There was a lot of pressure to come up with a working prototype as soon as possible. The Java (not JS!) language was starting to get traction. Sun Microsystems was making a big push for it and Netscape Communications was about to close a deal with them to make Java available in the browser. Enter a new language, Mocha. The idea at the time was that Java was not suited for the type of audience that would consume Mocha: Scripters, amateurs, designers. Java was just too big, too enterprisy (sic) for the role. There was a lot of internal pressure to pick one language as soon as possible. Python , Tcl and Scheme itself were all possible candidates. So Eich had to work fast. May 1995 - Eich had the luxury to choose features but had little time to build the language. In a matter of weeks, a working prototype was integrated into Netscape Communicator in May 1995. In the end, a Java-like syntax was required, and familiar semantics for many common idioms was also adopted. So Mocha was not like Scheme at all. It looked like a dynamic Java, but underneath it was a very different beast: a premature lovechild of Scheme and Self , with Java looks. Mocha was renamed to LiveScript . And later when Sun and Netscape closed the deal it was renamed JavaScript, a scripting language for small client-side tasks. Java would be promoted as a bigger, professional tool to develop rich web components. This first version of JavaScript set in stone many of the traits the language is known for today. In particular, its object-model , and its functional features were already present in this first version. August 1996 - At the moment (and for a very long time), web standards were not strong. So Microsoft implemented its own version of JavaScript, called JScript. JScript was different in more than just name. Slight differences in implementation, in particular with regards to certain DOM functions, caused ripples that would still be felt many years into the future. JavaScript wars were fought in more fronts than just names and timelines and many of its quirks are just the wounds of these wars. The first version of JScript was included with Internet Explorer 3.0, released in August 1996. In the fall of 1996, Eich rewrote most of Mocha into a cleaner implementation to pay off for the technical debt caused by rushing it out of the door. This new version of Netscape's JavaScript engine was called SpiderMonkey . SpiderMonkey is still the name of the JavaScript engine found in Firefox, Netscape Navigator's grandson. For the full article, that link again is A Brief History of JavaScript .","title":"A VERY Brief History of JavaScript"},{"location":"preCourse/setupInstructions/","text":"Prepare Your Machine(Setup Your Computer) To work in the course you'll need four essential tools on your machine (computer): a web browser , a text editor , a terminal or terminal emulator (a.k.a. command line interface or CLI) and the Node.js runtime environment . The short checklist looks like this: Download Chrome Download VS Code Terminal: MacOS has a built-in terminal Windows 10+ has Command Prompt Windows <=9 will need to download GitBash Download Node See It Chrome When consuming content through the internet, users/we need a program that can render the streams of data sent to our computer (laptop or phone) from other computers (the cloud) through the internet. The general name for this type of program is called a browser. Yes, you can surf the internet with other browsers like Internet Explore, Edge, Opera, Firefox or Safari, but Chrome undoubtedly has the strongest built-in dev tools of any browser. In this course and all the following courses we\u2019ll be using Chrome. Be sure to download Chrome. After that: Master Bookmark Management Organized Your Bookmarks Shortcut Practice: Cmd + T = open new tab Shortcut Practice: Cmd + Shift + T = reopen last closed tab Shortcut Practice: Cmd + R = refresh the current tab Shortcut Practice: Cmd + W = close the current tab NOTE: For Windows machines use Ctrl instead of Cmd . VS Code A text editor is simply a tool used to edit your code and organize it into files before it is executed. There are plenty of text editors or IDEs including Atom, SublimeText, IntelliJ, Brackets, WebStorm, VIM, TextWrangler, RubyMine and even NotePad. Some are paid, others are free, but for our use-case and to get the most powerful text editor for the buck we're going to use the free and well-supported Visual Studio Code . Be sure to download it and then continue to read up on other text editors as you grow as a developer. IDEs and TextEditors Why VS Code Learn & Practice More Keyboard Shortcuts NOTE: VS Code, Visual Studio and VS Community are all different text editors . Think of the terminal or CLI (command line interface) as a shortcut to the computer. Normally we access our computer's programs and files through a GUI (graphical user interface, pronounced: \"gooey\"). A GUI is nice and pretty, but sometimes we need to access the computer more directly and in a more efficient way. We can do this using the command line interface, or command line for short. Terminal or Terminal Emulator A terminal or Command Line Interface(CLI) is a way for you to interact with your computer's core functionality without building a GUI. GUI are what we give to people that don't know how to work with computers. We learn to work in terminals because later on we'll be interacting with remote servers and the only way we can talk to them is sending them messages through a CLI command. Macs Mac users have a built in terminal. To access it, simply hold Cmd + Space A Spotlight search bar should appear. Type in \"terminal\" then hit Enter . But you'll need homebrew so run this in your terminal: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" and say yes to XCode . [Learn how to work through your Mac terminal with a few short commands(https://youtu.be/5XgBd6rjuDQ)]. Windows 10+ Windows 10 comes built with Command Prompt , a command line interpreter. It acts the same way as the command line and is in this way a command line emulator. Open Command Prompt via the Command Prompt shortcut located in the Start menu or on the Apps screen, depending on your version of Windows. Learn how to use the Windows command line . Windows < 10 If you are using a pre-Windows 10 machine then you will need to download GitBash to work as your terminal emulator. Learn GitBash commands . NOTE: We'll use these terminals or terminal emulators throughout this course and each one afterward, so make sure you can access them for now. Node Node.js is a runtime environment that allows us to build applications(apps) in JavaScript and run them outside of a browser(the native place for JavaScript). With Node downloaded on our computer we'll be able to build terminal apps in 211, servers in 311 and web apps in 411! Go ahead and download Node but don't do anything with it until the Node Lesson later on. Node.js for Mac Node.js for Windows","title":"Prepare Your Machine"},{"location":"preCourse/setupInstructions/#prepare-your-machinesetup-your-computer","text":"To work in the course you'll need four essential tools on your machine (computer): a web browser , a text editor , a terminal or terminal emulator (a.k.a. command line interface or CLI) and the Node.js runtime environment . The short checklist looks like this: Download Chrome Download VS Code Terminal: MacOS has a built-in terminal Windows 10+ has Command Prompt Windows <=9 will need to download GitBash Download Node","title":"Prepare Your Machine(Setup Your Computer)"},{"location":"preCourse/setupInstructions/#see-it","text":"","title":"See It"},{"location":"preCourse/setupInstructions/#chrome","text":"When consuming content through the internet, users/we need a program that can render the streams of data sent to our computer (laptop or phone) from other computers (the cloud) through the internet. The general name for this type of program is called a browser. Yes, you can surf the internet with other browsers like Internet Explore, Edge, Opera, Firefox or Safari, but Chrome undoubtedly has the strongest built-in dev tools of any browser. In this course and all the following courses we\u2019ll be using Chrome. Be sure to download Chrome. After that: Master Bookmark Management Organized Your Bookmarks Shortcut Practice: Cmd + T = open new tab Shortcut Practice: Cmd + Shift + T = reopen last closed tab Shortcut Practice: Cmd + R = refresh the current tab Shortcut Practice: Cmd + W = close the current tab NOTE: For Windows machines use Ctrl instead of Cmd .","title":"Chrome"},{"location":"preCourse/setupInstructions/#vs-code","text":"A text editor is simply a tool used to edit your code and organize it into files before it is executed. There are plenty of text editors or IDEs including Atom, SublimeText, IntelliJ, Brackets, WebStorm, VIM, TextWrangler, RubyMine and even NotePad. Some are paid, others are free, but for our use-case and to get the most powerful text editor for the buck we're going to use the free and well-supported Visual Studio Code . Be sure to download it and then continue to read up on other text editors as you grow as a developer. IDEs and TextEditors Why VS Code Learn & Practice More Keyboard Shortcuts NOTE: VS Code, Visual Studio and VS Community are all different text editors . Think of the terminal or CLI (command line interface) as a shortcut to the computer. Normally we access our computer's programs and files through a GUI (graphical user interface, pronounced: \"gooey\"). A GUI is nice and pretty, but sometimes we need to access the computer more directly and in a more efficient way. We can do this using the command line interface, or command line for short.","title":"VS Code"},{"location":"preCourse/setupInstructions/#terminal-or-terminal-emulator","text":"A terminal or Command Line Interface(CLI) is a way for you to interact with your computer's core functionality without building a GUI. GUI are what we give to people that don't know how to work with computers. We learn to work in terminals because later on we'll be interacting with remote servers and the only way we can talk to them is sending them messages through a CLI command. Macs Mac users have a built in terminal. To access it, simply hold Cmd + Space A Spotlight search bar should appear. Type in \"terminal\" then hit Enter . But you'll need homebrew so run this in your terminal: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" and say yes to XCode . [Learn how to work through your Mac terminal with a few short commands(https://youtu.be/5XgBd6rjuDQ)]. Windows 10+ Windows 10 comes built with Command Prompt , a command line interpreter. It acts the same way as the command line and is in this way a command line emulator. Open Command Prompt via the Command Prompt shortcut located in the Start menu or on the Apps screen, depending on your version of Windows. Learn how to use the Windows command line . Windows < 10 If you are using a pre-Windows 10 machine then you will need to download GitBash to work as your terminal emulator. Learn GitBash commands . NOTE: We'll use these terminals or terminal emulators throughout this course and each one afterward, so make sure you can access them for now.","title":"Terminal or Terminal Emulator"},{"location":"preCourse/setupInstructions/#node","text":"Node.js is a runtime environment that allows us to build applications(apps) in JavaScript and run them outside of a browser(the native place for JavaScript). With Node downloaded on our computer we'll be able to build terminal apps in 211, servers in 311 and web apps in 411! Go ahead and download Node but don't do anything with it until the Node Lesson later on. Node.js for Mac Node.js for Windows","title":"Node"},{"location":"preCourse/succeedInThisCourse/","text":"How to Succeed In This Course and This Career If you\u2019ve completed 101 you already know how important it is for you to complete all of the pre-lesson homeworks before coming into class. Why? Our instructors don\u2019t lecture in class. Instead, our instructors guide you through multiple challenges including logic problems, presentations, interview questions, and application programming challenges. To use the class time effectively you and all of your classmates must complete the assigned pre-homework. If you and your classmates do this you\u2019ll be able to get into class and really ask good questions, apply what you\u2019re learning at home and advance your skills more quickly. This program is built to accommodate full-time employment through part-time classes BUT you will not learn everything you need to learn in these 5 hours/week. YOU MUST READ, WATCH, PRACTICE, and RESEARCH on your own. Each of the sections in your pre-lesson homeworks have been honed in through years of training student-developers to focus on what they really need to learn in a very short amount of time. Trust the process, do the work, sacrifice time now for your future, and GSD ! Flipped Classroom: What The short? You read and study outside of class and apply that knowledge in class with the support of your classmates and instructor. No pride. No ego. No shame. A more academic definition can be found here . But the following videos do well to explain it well. Either way, this approach works and works well. The only challenge now is to shape your mindset around it. The Flipped Classroom: Why In the traditional classroom , the teacher is the central focus of a lesson. The teacher responds to questions while students defer directly to the teacher for guidance and feedback. In a classroom with a traditional style of instruction, individual lessons may be focused on an explanation of content utilizing a lecture-style. Typically, this pattern of teaching also involves giving students the task of reading from a textbook or practicing a concept by working on a problem set, for example, outside school. In a flipped classroom students are required to study the content of the lecture outside of class by reading, watching videos and fiddling with code. Class time with the instructor is then mostly reserved for questions over the content, small discussions of related topics and then dedicated guided practice time on each project. This way students get access to a professional programmer when they need it, during problems and struggles. This approach may feel difficult at first but this methodology has been proven to work and is well suited for both adult learners and part-time education. The Flipped Classroom: How WATCH, READ, PRACTICE, RESEARCH, AND WRITE Every Pre-Homework will have a video to WATCH. These videos are incredibly important to help build context for why you\u2019ll be learning the upcoming concept. Watch all videos that are given to you even if they\u2019re 30 mins, 60 mins or just 5 mins. Watch them all! They were built or chosen because they teach what we need you to learn. READ ALL of the pre-homework given to you. Each lesson has been carefully thought out and crafted to guide you through, sometimes, very complex or technically intricate processes. Make sure you understand the concepts by reading every article that\u2019s suggested. PRACTICE Most pre-homework will have Practice It sections where you can apply the lesson you\u2019ve just watched and read about. This section is where you actually learn! Don\u2019t cut yourself short. DO THE PRACTICE PROBLEM ! Put it in a Repl.it and don\u2019t stop fidgeting with it until you completely understand it. RESEARCH your questions! ALL questions can be answered on the internet. Don\u2019t wait until you get to class to answer low hanging fruit. Find it on the internet. Then you can use your class time to ask harder questions with deeper understanding. At the end of most pre-lesson homeworks you\u2019ll see a list of Terms to Know & Questions for Discussion . If you can\u2019t describe or answer them to another person you need to go look them up on Google, read or watch a video on them, then WRITE down your understanding of each one in your journal. WRITE your blogging questions every week. You\u2019ll see a lesson on creating your blog account on Medium.com in the Pre-Course Lessons, so you can publish your thoughts on multiple subjects. These questions are collected from various interviews from our graduates and online research to prepare you for the hardest interview you\u2019ve ever experienced , the one you\u2019ll go through for your first developer job. Today's Shortcut - YouTube Videos While watching YouTube videos, Type Shift + > to accelerate the play speed of a video. Shift + < to slow it down. Simply type L to jump ahead by 10 seconds. And J to go back 10 seconds. Type C to turn on/off captions.","title":"The Flipped Classroom"},{"location":"preCourse/succeedInThisCourse/#how-to-succeed-in-this-course-and-this-career","text":"If you\u2019ve completed 101 you already know how important it is for you to complete all of the pre-lesson homeworks before coming into class. Why? Our instructors don\u2019t lecture in class. Instead, our instructors guide you through multiple challenges including logic problems, presentations, interview questions, and application programming challenges. To use the class time effectively you and all of your classmates must complete the assigned pre-homework. If you and your classmates do this you\u2019ll be able to get into class and really ask good questions, apply what you\u2019re learning at home and advance your skills more quickly. This program is built to accommodate full-time employment through part-time classes BUT you will not learn everything you need to learn in these 5 hours/week. YOU MUST READ, WATCH, PRACTICE, and RESEARCH on your own. Each of the sections in your pre-lesson homeworks have been honed in through years of training student-developers to focus on what they really need to learn in a very short amount of time. Trust the process, do the work, sacrifice time now for your future, and GSD !","title":"How to Succeed In This Course and This Career"},{"location":"preCourse/succeedInThisCourse/#flipped-classroom-what","text":"The short? You read and study outside of class and apply that knowledge in class with the support of your classmates and instructor. No pride. No ego. No shame. A more academic definition can be found here . But the following videos do well to explain it well. Either way, this approach works and works well. The only challenge now is to shape your mindset around it.","title":"Flipped Classroom: What"},{"location":"preCourse/succeedInThisCourse/#the-flipped-classroom-why","text":"In the traditional classroom , the teacher is the central focus of a lesson. The teacher responds to questions while students defer directly to the teacher for guidance and feedback. In a classroom with a traditional style of instruction, individual lessons may be focused on an explanation of content utilizing a lecture-style. Typically, this pattern of teaching also involves giving students the task of reading from a textbook or practicing a concept by working on a problem set, for example, outside school. In a flipped classroom students are required to study the content of the lecture outside of class by reading, watching videos and fiddling with code. Class time with the instructor is then mostly reserved for questions over the content, small discussions of related topics and then dedicated guided practice time on each project. This way students get access to a professional programmer when they need it, during problems and struggles. This approach may feel difficult at first but this methodology has been proven to work and is well suited for both adult learners and part-time education.","title":"The Flipped Classroom: Why"},{"location":"preCourse/succeedInThisCourse/#the-flipped-classroom-how","text":"WATCH, READ, PRACTICE, RESEARCH, AND WRITE Every Pre-Homework will have a video to WATCH. These videos are incredibly important to help build context for why you\u2019ll be learning the upcoming concept. Watch all videos that are given to you even if they\u2019re 30 mins, 60 mins or just 5 mins. Watch them all! They were built or chosen because they teach what we need you to learn. READ ALL of the pre-homework given to you. Each lesson has been carefully thought out and crafted to guide you through, sometimes, very complex or technically intricate processes. Make sure you understand the concepts by reading every article that\u2019s suggested. PRACTICE Most pre-homework will have Practice It sections where you can apply the lesson you\u2019ve just watched and read about. This section is where you actually learn! Don\u2019t cut yourself short. DO THE PRACTICE PROBLEM ! Put it in a Repl.it and don\u2019t stop fidgeting with it until you completely understand it. RESEARCH your questions! ALL questions can be answered on the internet. Don\u2019t wait until you get to class to answer low hanging fruit. Find it on the internet. Then you can use your class time to ask harder questions with deeper understanding. At the end of most pre-lesson homeworks you\u2019ll see a list of Terms to Know & Questions for Discussion . If you can\u2019t describe or answer them to another person you need to go look them up on Google, read or watch a video on them, then WRITE down your understanding of each one in your journal. WRITE your blogging questions every week. You\u2019ll see a lesson on creating your blog account on Medium.com in the Pre-Course Lessons, so you can publish your thoughts on multiple subjects. These questions are collected from various interviews from our graduates and online research to prepare you for the hardest interview you\u2019ve ever experienced , the one you\u2019ll go through for your first developer job.","title":"The Flipped Classroom: How"},{"location":"preCourse/succeedInThisCourse/#todays-shortcut-youtube-videos","text":"While watching YouTube videos, Type Shift + > to accelerate the play speed of a video. Shift + < to slow it down. Simply type L to jump ahead by 10 seconds. And J to go back 10 seconds. Type C to turn on/off captions.","title":"Today's Shortcut - YouTube Videos"},{"location":"preCourse/whatIsJavaScript/","text":"What is JavaScript First off, JavaScript is nothing even close to Java. Please do not confuse the two . The naming of JavaScript was a marketing tactic at the time of creation to make programmers feel comfortable with the new language and increase its popularity. In short, Java is to JavaScript as car is to carpet . Unlike HTML and CSS, JavaScript (JS) is a programming language. Instead of rendering content and telling it how it should look, JavaScript can decide what will be rendered, when it will be rendered, why it will be rendered, how it will be rendered and how much of it to be rendered on the screen. JS can control the flow of elements, information, and interactions. Think of it this way: If HTML is the bones of your web page and CSS is the meat and fat that fleshes it out, then JS is the brains that control the movement and flow of everything on the web page. At first, JS will seem daunting. In time you'll find it really isn't but because you've been working mostly in HTML and CSS it will feel overwhelming. I promise you it isn't and you will get it. But it will take a little bit of time and effort. Also, by learning JS you are simultaneously learning the fundamentals of programming which will make all other programming languages come easier later on. You're doing the hard work now! Strongly Suggested Additional Resources MDN Docs - What is JavaScript . Tutorial - \"Playing with browser objects\" Video - What Went Wrong? Troubleshooting JavaScript . Video - What Is JavaScript","title":"What is JavaScript"},{"location":"preCourse/whatIsJavaScript/#what-is-javascript","text":"First off, JavaScript is nothing even close to Java. Please do not confuse the two . The naming of JavaScript was a marketing tactic at the time of creation to make programmers feel comfortable with the new language and increase its popularity. In short, Java is to JavaScript as car is to carpet . Unlike HTML and CSS, JavaScript (JS) is a programming language. Instead of rendering content and telling it how it should look, JavaScript can decide what will be rendered, when it will be rendered, why it will be rendered, how it will be rendered and how much of it to be rendered on the screen. JS can control the flow of elements, information, and interactions. Think of it this way: If HTML is the bones of your web page and CSS is the meat and fat that fleshes it out, then JS is the brains that control the movement and flow of everything on the web page. At first, JS will seem daunting. In time you'll find it really isn't but because you've been working mostly in HTML and CSS it will feel overwhelming. I promise you it isn't and you will get it. But it will take a little bit of time and effort. Also, by learning JS you are simultaneously learning the fundamentals of programming which will make all other programming languages come easier later on. You're doing the hard work now!","title":"What is JavaScript"},{"location":"preCourse/whatIsJavaScript/#strongly-suggested-additional-resources","text":"MDN Docs - What is JavaScript . Tutorial - \"Playing with browser objects\" Video - What Went Wrong? Troubleshooting JavaScript . Video - What Is JavaScript","title":"Strongly Suggested Additional Resources"}]}